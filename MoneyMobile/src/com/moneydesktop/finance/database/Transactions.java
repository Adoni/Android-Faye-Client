package com.moneydesktop.finance.database;

import java.util.List;

import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.DaoException;
// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
// KEEP INCLUDES - put your custom includes here
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONObject;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.moneydesktop.finance.ApplicationContext;
import com.moneydesktop.finance.data.Constant;
// KEEP INCLUDES END
/**
 * Entity mapped to table TRANSACTIONS.
 */
public class Transactions extends BusinessObject  {

    private Long id;
    private Double amount;
    private Double amountReimbursable;
    private java.util.Date date;
    private java.util.Date datePosted;
    private Integer dayNumber;
    private Integer exclusionFlags;
    private Boolean hasReceipt;
    private Boolean hasSplit;
    private Boolean isBusiness;
    private Boolean isCleared;
    private Boolean isExcluded;
    private Boolean isFlagged;
    private Boolean isManual;
    private Boolean isMatched;
    private Boolean isProcessed;
    private Boolean isReimbursable;
    private Boolean isReported;
    private Boolean isReportedAndPaid;
    private Boolean isReportedAndSubmitted;
    private Boolean isSplit;
    private Boolean isVoid;
    private String memo;
    private Integer monthNumber;
    private Double normalizedAmount;
    private String originalCategory;
    private String originalTitle;
    private Integer quarterNumber;
    private Double rawAmount;
    private String reference;
    private String tagString;
    private String title;
    private String transactionId;
    private Integer transactionType;
    private Integer weekNumber;
    private Integer yearNumber;
    private Long bankAccountId;
    private Long categoryId;
    private Long parentTransactionId;
    private long businessObjectId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient TransactionsDao myDao;

    private BankAccount bankAccount;
    private Long bankAccount__resolvedKey;

    private Category category;
    private Long category__resolvedKey;

    private Transactions parent;
    private Long parent__resolvedKey;

    private BusinessObjectBase businessObjectBase;
    private Long businessObjectBase__resolvedKey;

    private List<Transactions> children;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public Transactions() {
    }

    public Transactions(Long id) {
        this.id = id;
    }

    public Transactions(Long id, Double amount, Double amountReimbursable, java.util.Date date, java.util.Date datePosted, Integer dayNumber, Integer exclusionFlags, Boolean hasReceipt, Boolean hasSplit, Boolean isBusiness, Boolean isCleared, Boolean isExcluded, Boolean isFlagged, Boolean isManual, Boolean isMatched, Boolean isProcessed, Boolean isReimbursable, Boolean isReported, Boolean isReportedAndPaid, Boolean isReportedAndSubmitted, Boolean isSplit, Boolean isVoid, String memo, Integer monthNumber, Double normalizedAmount, String originalCategory, String originalTitle, Integer quarterNumber, Double rawAmount, String reference, String tagString, String title, String transactionId, Integer transactionType, Integer weekNumber, Integer yearNumber, Long bankAccountId, Long categoryId, Long parentTransactionId, long businessObjectId) {
        this.id = id;
        this.amount = amount;
        this.amountReimbursable = amountReimbursable;
        this.date = date;
        this.datePosted = datePosted;
        this.dayNumber = dayNumber;
        this.exclusionFlags = exclusionFlags;
        this.hasReceipt = hasReceipt;
        this.hasSplit = hasSplit;
        this.isBusiness = isBusiness;
        this.isCleared = isCleared;
        this.isExcluded = isExcluded;
        this.isFlagged = isFlagged;
        this.isManual = isManual;
        this.isMatched = isMatched;
        this.isProcessed = isProcessed;
        this.isReimbursable = isReimbursable;
        this.isReported = isReported;
        this.isReportedAndPaid = isReportedAndPaid;
        this.isReportedAndSubmitted = isReportedAndSubmitted;
        this.isSplit = isSplit;
        this.isVoid = isVoid;
        this.memo = memo;
        this.monthNumber = monthNumber;
        this.normalizedAmount = normalizedAmount;
        this.originalCategory = originalCategory;
        this.originalTitle = originalTitle;
        this.quarterNumber = quarterNumber;
        this.rawAmount = rawAmount;
        this.reference = reference;
        this.tagString = tagString;
        this.title = title;
        this.transactionId = transactionId;
        this.transactionType = transactionType;
        this.weekNumber = weekNumber;
        this.yearNumber = yearNumber;
        this.bankAccountId = bankAccountId;
        this.categoryId = categoryId;
        this.parentTransactionId = parentTransactionId;
        this.businessObjectId = businessObjectId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getTransactionsDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Double getAmount() {
        return amount;
    }

    public void setAmount(Double amount) {
        this.amount = amount;
    }

    public Double getAmountReimbursable() {
        return amountReimbursable;
    }

    public void setAmountReimbursable(Double amountReimbursable) {
        this.amountReimbursable = amountReimbursable;
    }

    public java.util.Date getDate() {
        return date;
    }

    public void setDate(java.util.Date date) {
        this.date = date;
    }

    public java.util.Date getDatePosted() {
        return datePosted;
    }

    public void setDatePosted(java.util.Date datePosted) {
        this.datePosted = datePosted;
    }

    public Integer getDayNumber() {
        return dayNumber;
    }

    public void setDayNumber(Integer dayNumber) {
        this.dayNumber = dayNumber;
    }

    public Integer getExclusionFlags() {
        return exclusionFlags;
    }

    public void setExclusionFlags(Integer exclusionFlags) {
        this.exclusionFlags = exclusionFlags;
    }

    public Boolean getHasReceipt() {
        return hasReceipt;
    }

    public void setHasReceipt(Boolean hasReceipt) {
        this.hasReceipt = hasReceipt;
    }

    public Boolean getHasSplit() {
        return hasSplit;
    }

    public void setHasSplit(Boolean hasSplit) {
        this.hasSplit = hasSplit;
    }

    public Boolean getIsBusiness() {
        return isBusiness;
    }

    public void setIsBusiness(Boolean isBusiness) {
        this.isBusiness = isBusiness;
    }

    public Boolean getIsCleared() {
        return isCleared;
    }

    public void setIsCleared(Boolean isCleared) {
        this.isCleared = isCleared;
    }

    public Boolean getIsExcluded() {
        return isExcluded;
    }

    public void setIsExcluded(Boolean isExcluded) {
        this.isExcluded = isExcluded;
    }

    public Boolean getIsFlagged() {
        return isFlagged;
    }

    public void setIsFlagged(Boolean isFlagged) {
        this.isFlagged = isFlagged;
    }

    public Boolean getIsManual() {
        return isManual;
    }

    public void setIsManual(Boolean isManual) {
        this.isManual = isManual;
    }

    public Boolean getIsMatched() {
        return isMatched;
    }

    public void setIsMatched(Boolean isMatched) {
        this.isMatched = isMatched;
    }

    public Boolean getIsProcessed() {
        return isProcessed;
    }

    public void setIsProcessed(Boolean isProcessed) {
        this.isProcessed = isProcessed;
    }

    public Boolean getIsReimbursable() {
        return isReimbursable;
    }

    public void setIsReimbursable(Boolean isReimbursable) {
        this.isReimbursable = isReimbursable;
    }

    public Boolean getIsReported() {
        return isReported;
    }

    public void setIsReported(Boolean isReported) {
        this.isReported = isReported;
    }

    public Boolean getIsReportedAndPaid() {
        return isReportedAndPaid;
    }

    public void setIsReportedAndPaid(Boolean isReportedAndPaid) {
        this.isReportedAndPaid = isReportedAndPaid;
    }

    public Boolean getIsReportedAndSubmitted() {
        return isReportedAndSubmitted;
    }

    public void setIsReportedAndSubmitted(Boolean isReportedAndSubmitted) {
        this.isReportedAndSubmitted = isReportedAndSubmitted;
    }

    public Boolean getIsSplit() {
        return isSplit;
    }

    public void setIsSplit(Boolean isSplit) {
        this.isSplit = isSplit;
    }

    public Boolean getIsVoid() {
        return isVoid;
    }

    public void setIsVoid(Boolean isVoid) {
        this.isVoid = isVoid;
    }

    public String getMemo() {
        return memo;
    }

    public void setMemo(String memo) {
        this.memo = memo;
    }

    public Integer getMonthNumber() {
        return monthNumber;
    }

    public void setMonthNumber(Integer monthNumber) {
        this.monthNumber = monthNumber;
    }

    public Double getNormalizedAmount() {
        return normalizedAmount;
    }

    public void setNormalizedAmount(Double normalizedAmount) {
        this.normalizedAmount = normalizedAmount;
    }

    public String getOriginalCategory() {
        return originalCategory;
    }

    public void setOriginalCategory(String originalCategory) {
        this.originalCategory = originalCategory;
    }

    public String getOriginalTitle() {
        return originalTitle;
    }

    public void setOriginalTitle(String originalTitle) {
        this.originalTitle = originalTitle;
    }

    public Integer getQuarterNumber() {
        return quarterNumber;
    }

    public void setQuarterNumber(Integer quarterNumber) {
        this.quarterNumber = quarterNumber;
    }

    public Double getRawAmount() {
        return rawAmount;
    }

    public void setRawAmount(Double rawAmount) {
        this.rawAmount = rawAmount;
    }

    public String getReference() {
        return reference;
    }

    public void setReference(String reference) {
        this.reference = reference;
    }

    public String getTagString() {
        return tagString;
    }

    public void setTagString(String tagString) {
        this.tagString = tagString;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getTransactionId() {
        return transactionId;
    }

    public void setTransactionId(String transactionId) {
        this.transactionId = transactionId;
    }

    public Integer getTransactionType() {
        return transactionType;
    }

    public void setTransactionType(Integer transactionType) {
        this.transactionType = transactionType;
    }

    public Integer getWeekNumber() {
        return weekNumber;
    }

    public void setWeekNumber(Integer weekNumber) {
        this.weekNumber = weekNumber;
    }

    public Integer getYearNumber() {
        return yearNumber;
    }

    public void setYearNumber(Integer yearNumber) {
        this.yearNumber = yearNumber;
    }

    public Long getBankAccountId() {
        return bankAccountId;
    }

    public void setBankAccountId(Long bankAccountId) {
        this.bankAccountId = bankAccountId;
    }

    public Long getCategoryId() {
        return categoryId;
    }

    public void setCategoryId(Long categoryId) {
        this.categoryId = categoryId;
    }

    public Long getParentTransactionId() {
        return parentTransactionId;
    }

    public void setParentTransactionId(Long parentTransactionId) {
        this.parentTransactionId = parentTransactionId;
    }

    public long getBusinessObjectId() {
        return businessObjectId;
    }

    public void setBusinessObjectId(long businessObjectId) {
        this.businessObjectId = businessObjectId;
    }

    /** To-one relationship, resolved on first access. */
    public BankAccount getBankAccount() {
        if (bankAccount__resolvedKey == null || !bankAccount__resolvedKey.equals(bankAccountId)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            BankAccountDao targetDao = daoSession.getBankAccountDao();
            bankAccount = targetDao.load(bankAccountId);
            bankAccount__resolvedKey = bankAccountId;
        }
        return bankAccount;
    }

    public void setBankAccount(BankAccount bankAccount) {
        this.bankAccount = bankAccount;
        bankAccountId = bankAccount == null ? null : bankAccount.getId();
        bankAccount__resolvedKey = bankAccountId;
    }

    /** To-one relationship, resolved on first access. */
    public Category getCategory() {
        if (category__resolvedKey == null || !category__resolvedKey.equals(categoryId)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            CategoryDao targetDao = daoSession.getCategoryDao();
            category = targetDao.load(categoryId);
            category__resolvedKey = categoryId;
        }
        return category;
    }

    public void setCategory(Category category) {
        this.category = category;
        categoryId = category == null ? null : category.getId();
        category__resolvedKey = categoryId;
    }

    /** To-one relationship, resolved on first access. */
    public Transactions getParent() {
        if (parent__resolvedKey == null || !parent__resolvedKey.equals(parentTransactionId)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TransactionsDao targetDao = daoSession.getTransactionsDao();
            parent = targetDao.load(parentTransactionId);
            parent__resolvedKey = parentTransactionId;
        }
        return parent;
    }

    public void setParent(Transactions parent) {
        this.parent = parent;
        parentTransactionId = parent == null ? null : parent.getId();
        parent__resolvedKey = parentTransactionId;
    }

    /** To-one relationship, resolved on first access. */
    public BusinessObjectBase getBusinessObjectBase() {
        if (businessObjectBase__resolvedKey == null || !businessObjectBase__resolvedKey.equals(businessObjectId)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            BusinessObjectBaseDao targetDao = daoSession.getBusinessObjectBaseDao();
            businessObjectBase = targetDao.load(businessObjectId);
            businessObjectBase__resolvedKey = businessObjectId;
        }
        return businessObjectBase;
    }

    public void setBusinessObjectBase(BusinessObjectBase businessObjectBase) {
        if (businessObjectBase == null) {
            throw new DaoException("To-one property 'businessObjectId' has not-null constraint; cannot set to-one to null");
        }
        this.businessObjectBase = businessObjectBase;
        businessObjectId = businessObjectBase.getId();
        businessObjectBase__resolvedKey = businessObjectId;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<Transactions> getChildren() {
        if (children == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TransactionsDao targetDao = daoSession.getTransactionsDao();
            children = targetDao._queryTransactions_Children(id);
        }
        return children;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetChildren() {
        children = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    
    public void setExternalId(String id) {
    	setTransactionId(id);
    }
    
    public String getExternalId() {
    	return getTransactionId();
    }
    
    public static Transactions saveTransaction(JSONObject json, boolean delete) {
    	
    	Transactions transaction = (Transactions) saveObject(json, Transactions.class, delete);

    	// Object was deleted no need to continue
    	if (transaction == null)
    		return null;
    	
    	if (!json.optString(Constant.KEY_DUPLICATE).equals(Constant.VALUE_NULL) && (json.optBoolean(Constant.KEY_DUPLICATE) || json.optBoolean(Constant.KEY_ISDELETED) || json.optBoolean(Constant.KEY_IS_DELETED))) {
    		
    		// TODO: Notification with transactionId
    		
    		transaction.deleteBatch();
    		
    		return null;
    	}
    	
    	
    	if (transaction.isNew()) {
    		
    		transaction.setExclusionFlags(0);
    	
    	} else {

        	int serverVersion = json.optInt(Constant.KEY_REVISION, 0);
        	int localVersion = transaction.getBusinessObjectBase().getVersion();
        	
        	if (serverVersion == localVersion && serverVersion != 0) {
        		
        		return transaction;
        	
        	} else if (localVersion > serverVersion) {
        		
        		transaction.updateDataState();
        		
        		return transaction;
        	}
        	
        	transaction.getBusinessObjectBase().setVersion(serverVersion);
    	}
    	
    	transaction.setIgnoreWillSave(true);
    	transaction.getBusinessObjectBase().setExternalId(transaction.getExternalId());
    	transaction.setIsBusiness(!json.optBoolean(Constant.KEY_IS_PERSONAL));
    	
    	BankAccount bankAccount = (BankAccount) getObject(BankAccount.class, json.optString(Constant.KEY_ACCOUNT_GUID));
    	transaction.setBankAccountId(bankAccount.getId());
    	bankAccount.acceptChanges();
    	bankAccount.updateBatch();
    	
    	if (!json.optString(Constant.KEY_DATE).equals(Constant.VALUE_NULL))
    		transaction.setDate(new Date((json.optLong(Constant.KEY_DATE) * 1000)));
    	
    	if (!json.optString(Constant.KEY_POSTED_DATE).equals(Constant.VALUE_NULL))
    		transaction.setDatePosted(new Date((json.optLong(Constant.KEY_POSTED_DATE) * 1000)));
    	
    	if (!json.optString(Constant.KEY_HAS_BEEN_VIEWED).equals(Constant.VALUE_NULL))
    		transaction.setIsProcessed(json.optBoolean(Constant.KEY_HAS_BEEN_VIEWED));
    	
    	if (!json.optString(Constant.KEY_MEMO).equals(Constant.VALUE_NULL))
    		transaction.setMemo(json.optString(Constant.KEY_MEMO));
    	
    	if (!json.optString(Constant.KEY_USER_DESCRIPTION).equals(Constant.VALUE_NULL))
    		transaction.setTitle(json.optString(Constant.KEY_USER_DESCRIPTION));
    	
    	if (!json.optString(Constant.KEY_DESCRIPTION).equals(Constant.VALUE_NULL))
    		transaction.setOriginalTitle(json.optString(Constant.KEY_DESCRIPTION));
    	
    	if (!json.optString(Constant.KEY_REFERENCE).equals(Constant.VALUE_NULL))
    		transaction.setReference(json.optString(Constant.KEY_REFERENCE));
    	
    	transaction.getBusinessObjectBase().setFlags(json.optInt(Constant.KEY_FLAGS, 0));
    	
		transaction.setIsFlagged(json.optBoolean(Constant.KEY_IS_FLAGGED));
		transaction.setIsVoid(json.optBoolean(Constant.KEY_IS_VOID));
		transaction.setIsManual(json.optBoolean(Constant.KEY_IS_MANUAL));
		transaction.setIsMatched(false);
		transaction.setIsCleared(json.optBoolean(Constant.KEY_IS_CLEARED));
		transaction.setIsReimbursable(json.optBoolean(Constant.KEY_IS_REIMBURSABLE));
		transaction.setIsExcluded(json.optBoolean(Constant.KEY_IS_HIDDEN));
    	
    	JSONArray tags = json.optJSONArray(Constant.KEY_TAGS);
    	
    	if (tags != null)
    		Tag.saveArrayOfTags(tags, transaction);
    	
    	if (!json.optString(Constant.KEY_PARENT_GUID).equals(Constant.VALUE_NULL)) {
    		
    		Transactions parent = (Transactions) getObject(Transactions.class, json.optString(Constant.KEY_PARENT_GUID));
    		
    		if (parent != null) {
    			
    			transaction.setParentTransactionId(parent.getId());
    			parent.acceptChanges();
    			parent.updateBatch();
    		}
    	}
    	
    	transaction.setAmount(json.optDouble(Constant.KEY_AMOUNT));
    	transaction.setAmountReimbursable(transaction.getAmount());
    	
    	transaction.setTransactionType(json.optInt(Constant.KEY_TRANSACTION_TYPE));
    	
    	Double raw = transaction.getAmount();
    	raw *= (transaction.getTransactionType() == 1) ? -1 : 1;
    	transaction.setRawAmount(raw);
    	
    	Calendar cal = Calendar.getInstance(Locale.US);
    	cal.setTime(transaction.getDate());
    	
    	transaction.setYearNumber(cal.get(Calendar.YEAR));
    	transaction.setMonthNumber((cal.get(Calendar.MONTH) + 1));
    	transaction.setQuarterNumber(((cal.get(Calendar.MONTH) / 3) + 1));
    	transaction.setWeekNumber(cal.get(Calendar.WEEK_OF_YEAR));
    	transaction.setDayNumber(cal.get(Calendar.DAY_OF_MONTH));
    	
    	transaction.setTransactionType(json.optInt(Constant.KEY_TRANSACTION_TYPE));
    	transaction.setHasReceipt(false);
    	
    	if (json.has(Constant.KEY_CATEGORY_GUID)) {
    		
    		Category category = (Category) getObject(Category.class, json.optString(Constant.KEY_CATEGORY_GUID));
    		
    		if (category != null) {
    			
    			transaction.setCategoryId(category.getId());
    			category.acceptChanges();
    			category.updateBatch();
    		}
    	}
    	
    	transaction.acceptChanges();
    	
    	return transaction;
    }
    
    @SuppressWarnings("rawtypes")
	public static List<Map> summarizedTransactions(Long id) {
    	
    	String guid = Long.toString(id);
    	
    	SQLiteDatabase db = ApplicationContext.getDb();
    	Cursor cursor = db.rawQuery("SELECT DATE, sum(RAW_AMOUNT) FROM TRANSACTIONS WHERE BANK_ACCOUNT_ID = ? GROUP BY DATE ORDER BY DATE ASC", new String[] { guid });
    	
    	cursor.moveToFirst();
    	
    	List<Map> list = new ArrayList<Map>();
    	
    	while (cursor.isAfterLast() == false) {
    		
    		Map<String, Object> map = new HashMap<String, Object>();
    		map.put(Constant.KEY_DATE, new Date(cursor.getLong(0)));
    		map.put(Constant.KEY_AMOUNT, Double.valueOf(cursor.getDouble(1)));
    		
    		list.add(map);
    		
    		cursor.moveToNext();
    	}
    	
    	return list;
    }
    
    // KEEP METHODS END

}

package com.moneydesktop.finance.database;

import com.moneydesktop.finance.data.Constant;
import com.moneydesktop.finance.data.DataController;
import com.moneydesktop.finance.data.Enums;
import com.moneydesktop.finance.data.Enums.AccountExclusionFlags;
import com.moneydesktop.finance.data.Enums.DataState;
import com.moneydesktop.finance.model.User;
import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.DaoException;
import org.json.JSONException;
import org.json.JSONObject;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.text.SimpleDateFormat;
import java.util.*;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table BANK_ACCOUNT.
 */
public class BankAccount extends BusinessObject  {

    private Long id;
    private String accountId;
    private String accountName;
    private String accountNumber;
    private Double balance;
    private String bankName;
    private Double beginningBalance;
    private Double creditLimit;
    private String defaultClassId;
    private Integer dueDay;
    private Integer exclusionFlags;
    private String institutionId;
    private Double interestRate;
    private Boolean isExcluded;
    private Boolean isHolding;
    private Boolean isLinked;
    private Double localBalance;
    private Double minimumPayment;
    private Integer mortgageTotal;
    private String notes;
    private String originalName;
    private Integer propertyType;
    private Integer transactionCount;
    private Long bankAccountId;
    private long businessObjectId;
    private Long accountTypeId;
    private Long subAccountTypeId;
	private static int mExclusion;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient BankAccountDao myDao;

    private Bank bank;
    private Long bank__resolvedKey;

    private BusinessObjectBase businessObjectBase;
    private Long businessObjectBase__resolvedKey;

    private AccountType accountType;
    private Long accountType__resolvedKey;

    private AccountType subAccountType;
    private Long subAccountType__resolvedKey;

    private List<BankAccountBalance> bankAccountBalances;
    private List<Transactions> transactions;

    // KEEP FIELDS - put your custom fields here

    private static SimpleDateFormat dateFormat = new SimpleDateFormat("MM-dd-yyyy", Locale.US);
    // KEEP FIELDS END

    public BankAccount() {
    }

    public BankAccount(Long id) {
        this.id = id;
    }

    public BankAccount(Long id, String accountId, String accountName, String accountNumber, Double balance, String bankName, Double beginningBalance, Double creditLimit, String defaultClassId, Integer dueDay, Integer exclusionFlags, String institutionId, Double interestRate, Boolean isExcluded, Boolean isHolding, Boolean isLinked, Double localBalance, Double minimumPayment, Integer mortgageTotal, String notes, String originalName, Integer propertyType, Integer transactionCount, Long bankAccountId, long businessObjectId, Long accountTypeId, Long subAccountTypeId) {
        this.id = id;
        this.accountId = accountId;
        this.accountName = accountName;
        this.accountNumber = accountNumber;
        this.balance = balance;
        this.bankName = bankName;
        this.beginningBalance = beginningBalance;
        this.creditLimit = creditLimit;
        this.defaultClassId = defaultClassId;
        this.dueDay = dueDay;
        this.exclusionFlags = exclusionFlags;
        this.institutionId = institutionId;
        this.interestRate = interestRate;
        this.isExcluded = isExcluded;
        this.isHolding = isHolding;
        this.isLinked = isLinked;
        this.localBalance = localBalance;
        this.minimumPayment = minimumPayment;
        this.mortgageTotal = mortgageTotal;
        this.notes = notes;
        this.originalName = originalName;
        this.propertyType = propertyType;
        this.transactionCount = transactionCount;
        this.bankAccountId = bankAccountId;
        this.businessObjectId = businessObjectId;
        this.accountTypeId = accountTypeId;
        this.subAccountTypeId = subAccountTypeId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getBankAccountDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getAccountId() {
        return accountId;
    }

    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }

    public String getAccountName() {
        return accountName;
    }

    public void setAccountName(String accountName) {
        this.accountName = accountName;
    }

    public String getAccountNumber() {
        return accountNumber;
    }

    public void setAccountNumber(String accountNumber) {
        this.accountNumber = accountNumber;
    }

    public Double getBalance() {
        return balance;
    }

    public void setBalance(Double balance) {
        this.balance = balance;
    }

    public String getBankName() {
        return bankName;
    }

    public void setBankName(String bankName) {
        this.bankName = bankName;
    }

    public Double getBeginningBalance() {
        return beginningBalance;
    }

    public void setBeginningBalance(Double beginningBalance) {
        this.beginningBalance = beginningBalance;
    }

    public Double getCreditLimit() {
        return creditLimit;
    }

    public void setCreditLimit(Double creditLimit) {
        this.creditLimit = creditLimit;
    }

    public String getDefaultClassId() {
        return defaultClassId;
    }

    public void setDefaultClassId(String defaultClassId) {
        this.defaultClassId = defaultClassId;
    }

    public Integer getDueDay() {
        return dueDay;
    }

    public void setDueDay(Integer dueDay) {
        this.dueDay = dueDay;
    }

    public Integer getExclusionFlags() {
        return exclusionFlags;
    }

    public void setExclusionFlags(Integer exclusionFlags) {
        this.exclusionFlags = exclusionFlags;
    }

    public String getInstitutionId() {
        return institutionId;
    }

    public void setInstitutionId(String institutionId) {
        this.institutionId = institutionId;
    }

    public Double getInterestRate() {
        return interestRate;
    }

    public void setInterestRate(Double interestRate) {
        this.interestRate = interestRate;
    }

    public Boolean getIsExcluded() {
        return isExcluded;
    }

    public void setIsExcluded(Boolean isExcluded) {
        this.isExcluded = isExcluded;
    }

    public Boolean getIsHolding() {
        return isHolding;
    }

    public void setIsHolding(Boolean isHolding) {
        this.isHolding = isHolding;
    }

    public Boolean getIsLinked() {
        return isLinked;
    }

    public void setIsLinked(Boolean isLinked) {
        this.isLinked = isLinked;
    }

    public Double getLocalBalance() {
        return localBalance;
    }

    public void setLocalBalance(Double localBalance) {
        this.localBalance = localBalance;
    }

    public Double getMinimumPayment() {
        return minimumPayment;
    }

    public void setMinimumPayment(Double minimumPayment) {
        this.minimumPayment = minimumPayment;
    }

    public Integer getMortgageTotal() {
        return mortgageTotal;
    }

    public void setMortgageTotal(Integer mortgageTotal) {
        this.mortgageTotal = mortgageTotal;
    }

    public String getNotes() {
        return notes;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    public String getOriginalName() {
        return originalName;
    }

    public void setOriginalName(String originalName) {
        this.originalName = originalName;
    }

    public Integer getPropertyType() {
        return propertyType;
    }

    public void setPropertyType(Integer propertyType) {
        this.propertyType = propertyType;
    }

    public Integer getTransactionCount() {
        return transactionCount;
    }

    public void setTransactionCount(Integer transactionCount) {
        this.transactionCount = transactionCount;
    }

    public Long getBankAccountId() {
        return bankAccountId;
    }

    public void setBankAccountId(Long bankAccountId) {
        this.bankAccountId = bankAccountId;
    }

    public long getBusinessObjectId() {
        return businessObjectId;
    }

    public void setBusinessObjectId(long businessObjectId) {
        this.businessObjectId = businessObjectId;
    }

    public Long getAccountTypeId() {
        return accountTypeId;
    }

    public void setAccountTypeId(Long accountTypeId) {
        this.accountTypeId = accountTypeId;
    }

    public Long getSubAccountTypeId() {
        return subAccountTypeId;
    }

    public void setSubAccountTypeId(Long subAccountTypeId) {
        this.subAccountTypeId = subAccountTypeId;
    }

    /** To-one relationship, resolved on first access. */
    public Bank getBank() {
        Long __key = this.bankAccountId;
        if (bank__resolvedKey == null || !bank__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            BankDao targetDao = daoSession.getBankDao();
            Bank bankNew = targetDao.load(__key);
            synchronized (this) {
                bank = bankNew;
            	bank__resolvedKey = __key;
            }
        }
        return bank;
    }

    public void setBank(Bank bank) {
        synchronized (this) {
            this.bank = bank;
            bankAccountId = bank == null ? null : bank.getId();
            bank__resolvedKey = bankAccountId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public BusinessObjectBase getBusinessObjectBase() {
        long __key = this.businessObjectId;
        if (businessObjectBase__resolvedKey == null || !businessObjectBase__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            BusinessObjectBaseDao targetDao = daoSession.getBusinessObjectBaseDao();
            BusinessObjectBase businessObjectBaseNew = targetDao.load(__key);
            synchronized (this) {
                businessObjectBase = businessObjectBaseNew;
            	businessObjectBase__resolvedKey = __key;
            }
        }
        return businessObjectBase;
    }

    public void setBusinessObjectBase(BusinessObjectBase businessObjectBase) {
        if (businessObjectBase == null) {
            throw new DaoException("To-one property 'businessObjectId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.businessObjectBase = businessObjectBase;
            businessObjectId = businessObjectBase.getId();
            businessObjectBase__resolvedKey = businessObjectId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public AccountType getAccountType() {
        Long __key = this.accountTypeId;
        if (accountType__resolvedKey == null || !accountType__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AccountTypeDao targetDao = daoSession.getAccountTypeDao();
            AccountType accountTypeNew = targetDao.load(__key);
            synchronized (this) {
                accountType = accountTypeNew;
            	accountType__resolvedKey = __key;
            }
        }
        return accountType;
    }

    public void setAccountType(AccountType accountType) {
        synchronized (this) {
            this.accountType = accountType;
            accountTypeId = accountType == null ? null : accountType.getId();
            accountType__resolvedKey = accountTypeId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public AccountType getSubAccountType() {
        Long __key = this.subAccountTypeId;
        if (subAccountType__resolvedKey == null || !subAccountType__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AccountTypeDao targetDao = daoSession.getAccountTypeDao();
            AccountType subAccountTypeNew = targetDao.load(__key);
            synchronized (this) {
                subAccountType = subAccountTypeNew;
            	subAccountType__resolvedKey = __key;
            }
        }
        return subAccountType;
    }

    public void setSubAccountType(AccountType subAccountType) {
        synchronized (this) {
            this.subAccountType = subAccountType;
            subAccountTypeId = subAccountType == null ? null : subAccountType.getId();
            subAccountType__resolvedKey = subAccountTypeId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<BankAccountBalance> getBankAccountBalances() {
        if (bankAccountBalances == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            BankAccountBalanceDao targetDao = daoSession.getBankAccountBalanceDao();
            List<BankAccountBalance> bankAccountBalancesNew = targetDao._queryBankAccount_BankAccountBalances(id);
            synchronized (this) {
                if(bankAccountBalances == null) {
                    bankAccountBalances = bankAccountBalancesNew;
                }
            }
        }
        return bankAccountBalances;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetBankAccountBalances() {
        bankAccountBalances = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Transactions> getTransactions() {
        if (transactions == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TransactionsDao targetDao = daoSession.getTransactionsDao();
            List<Transactions> transactionsNew = targetDao._queryBankAccount_Transactions(id);
            synchronized (this) {
                if(transactions == null) {
                    transactions = transactionsNew;
                }
            }
        }
        return transactions;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetTransactions() {
        transactions = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here

    @Override
    public void setExternalId(String id) {
        setAccountId(id);
        getBusinessObjectBase().setExternalId(id);
    }

    @Override
    public String getExternalId() {
        return getAccountId();
    }
    
    public static List<AccountExclusionFlags> getExclusionsForAccount(BankAccount account) {
		mExclusion = account.getExclusionFlags();
		
		List<AccountExclusionFlags> exclusionFlags = new ArrayList<AccountExclusionFlags>();

		for (int i = 0; i <= AccountExclusionFlags.size(); i++) {
			AccountExclusionFlags flag = getShowHideOptions();
			if (flag != null) {
				exclusionFlags.add(flag);
			}
		}
			
    	return exclusionFlags;    	
    }
    
	private static AccountExclusionFlags getShowHideOptions() {
		AccountExclusionFlags flag = null;
		if (mExclusion != 0) {			
			if (mExclusion >= AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_EXPENSES.index()) {
				mExclusion = mExclusion - AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_EXPENSES.index();
				flag = AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_EXPENSES;
				
			} else if (mExclusion >= AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_INCOME.index()) {
				mExclusion = mExclusion - AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_INCOME.index();
				flag = AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_INCOME;
				
			} else if (mExclusion >= AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_BUDGETS.index()) {
				mExclusion = mExclusion - AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_BUDGETS.index();
				flag = AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_BUDGETS;
				
			} else if (mExclusion >= AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_ACCOUNT_LIST.index()) {
				mExclusion = mExclusion - AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_ACCOUNT_LIST.index();
				flag = AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_ACCOUNT_LIST;
				
			} else if (mExclusion >= AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_REPORTS.index()) {
				mExclusion = mExclusion - AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_REPORTS.index();
				flag = AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_REPORTS;
				
			} else if (mExclusion >= AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSACTION_LIST.index()) {
				mExclusion = mExclusion - AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSACTION_LIST.index();
				flag = AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSACTION_LIST;
				
			} else if (mExclusion >= AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_DEBT.index()) {
				mExclusion = mExclusion - AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_DEBT.index();
				flag = AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_DEBT;				
			}
		}
		
		return flag;
	}

    public static BankAccount saveBankAccount(JSONObject json, boolean delete) {

        BankAccount bankAccount = (BankAccount) saveObject(json, BankAccount.class, delete);

        if (bankAccount == null)
            return null;

        int serverVersion = json.optInt(Constant.KEY_REVISION, 0);
        int localVersion = bankAccount.getBusinessObjectBase().getVersion();

        if (serverVersion <= localVersion && serverVersion != 0)
            return bankAccount;

        if (bankAccount.isNew()) {

            bankAccount.setExclusionFlags(AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_EXPENSES.index()
                            | AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_INCOME.index());
            bankAccount.setIsHolding(false);

            if (json.has(Constant.KEY_MEMBER_GUID)) {

                Bank bank = (Bank) getObject(Bank.class, json.optString(Constant.KEY_MEMBER_GUID));

                if (bank != null) {
                    bankAccount.setBank(bank);
                    bank.acceptChanges();
                    bank.updateBatch();
                }
            }
        }

        if (!json.optString(Constant.KEY_INSTITUTION_GUID).equals(Constant.VALUE_NULL))
            bankAccount.setInstitutionId(json.optString(Constant.KEY_INSTITUTION_GUID));

        if (!json.optString(Constant.KEY_USER_NAME).equals(Constant.VALUE_NULL))
            bankAccount.setAccountName(json.optString(Constant.KEY_USER_NAME));

        if (!json.optString(Constant.KEY_NAME).equals(Constant.VALUE_NULL))
            bankAccount.setOriginalName(json.optString(Constant.KEY_NAME));

        if (!json.optString(Constant.KEY_INTEREST_RATE).equals(Constant.VALUE_NULL))
            bankAccount.setInterestRate(json.optDouble(Constant.KEY_INTEREST_RATE));

        if (!json.optString(Constant.KEY_CREDIT_LIMIT).equals(Constant.VALUE_NULL))
            bankAccount.setCreditLimit(json.optDouble(Constant.KEY_CREDIT_LIMIT));

        if (!json.optString(Constant.KEY_IS_HOLDING).equals(Constant.VALUE_NULL))
            bankAccount.setIsHolding(json.optBoolean(Constant.KEY_IS_HOLDING));

        if (!json.optString(Constant.KEY_MIN_PAYMENT).equals(Constant.VALUE_NULL))
            bankAccount.setMinimumPayment(json.optDouble(Constant.KEY_MIN_PAYMENT));

        if (!json.optString(Constant.KEY_DAY_DUE).equals(Constant.VALUE_NULL))
            bankAccount.setDueDay(json.optInt(Constant.KEY_DAY_DUE));

        if (!json.optString(Constant.KEY_IS_MANUAL).equals(Constant.VALUE_NULL))
            bankAccount.setIsLinked(!json.optBoolean(Constant.KEY_IS_MANUAL));

        if (!json.optString(Constant.KEY_IS_PERSONAL).equals(Constant.VALUE_NULL))
            bankAccount
                    .setDefaultClassId(json.optBoolean(Constant.KEY_IS_PERSONAL) ? Constant.PERSONAL
                            : Constant.BUSINESS);

        if (serverVersion != -1)
            bankAccount.getBusinessObjectBase().setVersion(serverVersion);

        if (!json.optString(Constant.KEY_FLAGS).equals(Constant.VALUE_NULL))
            bankAccount.getBusinessObjectBase().setFlags(json.optInt(Constant.KEY_FLAGS));

        if (!json.optString(Constant.KEY_IS_HIDDEN).equals(Constant.VALUE_NULL))
            bankAccount.setIsExcluded(json.optBoolean(Constant.KEY_IS_HIDDEN));

        if (!json.optString(Constant.KEY_BALANCE).equals(Constant.VALUE_NULL))
            bankAccount.setBalance(json.optDouble(Constant.KEY_BALANCE));

        if (!json.optString(Constant.KEY_ACCOUNT_TYPE).equals(Constant.VALUE_NULL)) {

            AccountType accountType = (AccountType) getObject(AccountType.class,
                    json.optString(Constant.KEY_ACCOUNT_TYPE));

            if (accountType != null) {

                bankAccount.setAccountType(accountType);
                accountType.acceptChanges();
                accountType.updateBatch();
            }
        }

        if (!json.optString(Constant.KEY_PROPERTY_TYPE).equals(Constant.VALUE_NULL)) {

            String subGuid = String.format("8.%d", json.optInt(Constant.KEY_PROPERTY_TYPE));

            AccountType accountType = (AccountType) getObject(AccountType.class, subGuid);

            if (accountType != null) {

                bankAccount.setSubAccountType(accountType);
                accountType.acceptChanges();
                accountType.updateBatch();
            }
        }

        if (!json.optString(Constant.KEY_ORG_BALANCE).equals(Constant.VALUE_NULL))
            bankAccount.setBeginningBalance(json.optDouble(Constant.KEY_ORG_BALANCE));

        bankAccount.setIsHolding(false);
        bankAccount.getBusinessObjectBase().setExternalId(bankAccount.getAccountId());
        bankAccount.setExclusionFlags(bankAccount.getExclusionFlags()
                | AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_ACCOUNT_LIST.index());

        bankAccount.acceptChanges();

        return bankAccount;
    }
    
    

    /**
     * Iterate through each Bank and then each Bank Account and create a bank
     * account balance on a per day basis.
     */
    @SuppressWarnings({
            "unchecked", "rawtypes"
    })
    public static void buildAccountBalances() {

        DataController.deleteData(BankAccountBalance.class);

        List<Bank> banks = (List<Bank>) DataController.getDao(Bank.class).loadAll();

        // Iterate through each bank
        for (Bank bank : banks) {

            // Iterate through each bank account
            for (BankAccount bankAccount : bank.getBankAccounts()) {

                // Get the bank account's current balance
                double balance = bankAccount.getBalance();

                // Get a list of summed transactions grouped by date
                List<Map> transactionSet = Transactions.summarizedTransactions(bankAccount.getId());

                if (transactionSet.size() > 0) {

                    // Convert the list of summed transactions to a map for easy
                    // lookup by date
                    Map<String, Double> summedAmounts = toMap(transactionSet);

                    boolean isFinancial = bankAccount.getAccountType().getFinancialAccountType() == 0;

                    // The oldest transaction will be the first in the list due
                    // to our query
                    Map<String, Object> oldest = transactionSet.get(0);
                    GregorianCalendar oldestCal = new GregorianCalendar();
                    oldestCal.setTime((Date) oldest.get(Constant.KEY_DATE));

                    // Subtract one day to make our iteration inclusive of this
                    // transaction
                    oldestCal.add(Calendar.DAY_OF_YEAR, -1);

                    Date today = new Date();
                    GregorianCalendar cal = new GregorianCalendar();
                    cal.setTime(today);

                    // Iterate through each day from today to the oldest date in
                    // our transaction set
                    while (cal.getTime().after(oldestCal.getTime())) {

                        Date day = cal.getTime();
                        String time = dateFormat.format(day);

                        // Create the account balance for the given day
                        BankAccountBalance bab = new BankAccountBalance();
                        bab.setBalance(balance);
                        bab.setDate(day);
                        bab.setBankAccountId(bankAccount.getId());
                        bab.insertBatch();

                        // If the given day has transactions modify the account
                        // balance
                        if (summedAmounts.containsKey(time)) {

                            Double amount = summedAmounts.get(time);

                            if (isFinancial)
                                balance += amount;
                            else
                                balance -= amount;
                        }

                        // Decrement the current date by one day
                        cal.add(Calendar.DAY_OF_YEAR, -1);
                    }
                }
                bankAccount.acceptChanges();
                bankAccount.updateBatch();
            }
            bank.acceptChanges();
            bank.updateBatch();
        }

        DataController.save();
    }

    /**
     * Create a single map from a list of maps with the date (formatted as
     * MM-DD-YYYY) as the key and the amount as the value.
     * 
     * @param expenses
     * @return
     */
    @SuppressWarnings("rawtypes")
    private static Map<String, Double> toMap(List<Map> expenses) {

        Map<String, Double> response = new HashMap<String, Double>();

        for (Map<String, Object> map : expenses) {
            Date date = (Date) map.get(Constant.KEY_DATE);
            response.put(dateFormat.format(date), (Double) map.get(Constant.KEY_AMOUNT));
        }

        return response;
    }

    @Override
    public JSONObject getJson() throws JSONException {

        JSONObject json = new JSONObject();

        if (getExternalId() != null)
            json.put(Constant.KEY_EXTERNAL_ID, getExternalId());

        if (getAccountId() != null
                && getBusinessObjectBase().getDataStateEnum() != DataState.DATA_STATE_NEW)
            json.put(Constant.KEY_GUID, getAccountId());

        if (getBusinessObjectBase().getDataStateEnum() == DataState.DATA_STATE_DELETED)
            return json;

        json.put(Constant.KEY_USER_GUID, User.getCurrentUser().getUserId());

        json.put(Constant.KEY_MEMBER_GUID, (getBank() != null && getBank().getBankId() != null) ? getBank().getBankId()
                : null);

        if (getAccountName() != null)
            json.put(Constant.KEY_USER_NAME, getAccountName());

        if (getOriginalName() != null)
            json.put(Constant.KEY_NAME, getOriginalName());
        else if (getAccountName() != null)
            json.put(Constant.KEY_NAME, getAccountName());

        if (getAccountType() != null && getAccountType().getAccountTypeId() != null)
            json.put(Constant.KEY_ACCOUNT_TYPE,
                    getAccountType().getAccountTypeId().replace(Constant.KEY_ACCOUNTTYPE, ""));

        if (getSubAccountType() != null) {

            String enumString = getSubAccountType().getAccountTypeId().split("\\.")[0];
            Integer propertyType = Integer.parseInt(enumString);

            if (propertyType != null)
                json.put(Constant.KEY_PROPERTY_TYPE, propertyType);
        }

        if (getDueDay() != null && getDueDay() != 0)
            json.put(Constant.KEY_DAY_DUE, getDueDay());

        if (getBeginningBalance() != null)
            json.put(Constant.KEY_ORG_BALANCE, getBeginningBalance());
        else
            json.put(Constant.KEY_ORG_BALANCE, 0.0);

        if (getExclusionFlags() != null)
            json.put(Constant.KEY_FLAGS, getExclusionFlags());
        else
            json.put(Constant.KEY_FLAGS, 0);

        json.put(Constant.KEY_IS_HIDDEN, (getIsExcluded() != null && getIsExcluded()) ? 1 : 0);

        if (getIsLinked() != null && !getIsLinked())
            json.put(Constant.KEY_IS_MANUAL, getIsLinked() ? 0 : 1);

        if (getCreditLimit() != null)
            json.put(Constant.KEY_CREDIT_LIMIT, getCreditLimit());

        if (getBalance() != null)
            json.put(Constant.KEY_BALANCE, getBalance());

        if (getMinimumPayment() != null)
            json.put(Constant.KEY_MIN_PAYMENT, getMinimumPayment());

        if (getInterestRate() != null)
            json.put(Constant.KEY_INTEREST_RATE, getInterestRate());
        else
            json.put(Constant.KEY_INTEREST_RATE, 0.0);

        if (getDefaultClassId() != null)
            json.put(Constant.KEY_IS_PERSONAL, getDefaultClassId().equals(Constant.PERSONAL) ? 1
                    : 0);

        if (getBusinessObjectBase().getVersion() != null)
            json.put(Constant.KEY_REVISION, getBusinessObjectBase().getVersion());

        json.put(Constant.KEY_IS_DELETED,
                getBusinessObjectBase().getDataStateEnum() == DataState.DATA_STATE_DELETED ? 1 : 0);

        return json;
    }

    public static BankAccount createBankAccount(AccountType accountType, double balance, String accountName) {

        SecureRandom random = new SecureRandom();
        String externalId = new BigInteger(130, random).toString(32).toUpperCase();

        BankAccount bankAccount = new BankAccount();
        bankAccount.setAccountId(externalId);
        bankAccount.setAccountType(accountType);
        bankAccount.setBalance(balance);
        bankAccount.setBeginningBalance(balance);
        bankAccount.setAccountName(accountName);

        if (accountType.getParent() != null) {
            bankAccount.setAccountType(accountType.getParent());
            bankAccount.setSubAccountType(accountType);
        }

        bankAccount.setExclusionFlags(AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_EXPENSES.index()|
                                      AccountExclusionFlags.ACCOUNT_EXCLUSION_FLAGS_TRANSFERS_FROM_INCOME.index());

        bankAccount.setIsLinked(false);
        bankAccount.setIsHolding(false);
        bankAccount.setIsExcluded(false);
        bankAccount.setDefaultClassId(Constant.PERSONAL);
        bankAccount.setDueDay(0);
        bankAccount.setInterestRate(0.0);
        bankAccount.setLocalBalance(0.0);
        bankAccount.setMinimumPayment(0.0);
        bankAccount.setMortgageTotal(0);
        bankAccount.setPropertyType(0);
        bankAccount.setTransactionCount(0);

        return bankAccount;
    }

    public void updateManualAccount(JSONObject json) {

        JSONObject account = json.optJSONObject(Constant.KEY_ACCOUNT);
        String accountId = account.optString(Constant.KEY_GUID);
        String memberId = account.optString(Constant.KEY_MEMBER_GUID);
        String institutionId = account.optString(Constant.KEY_INSTITUTION_GUID);
        int version = account.optInt(Constant.KEY_REVISION);

        setExternalId(accountId);
        getBusinessObjectBase().setVersion(version);

        if (memberId != null) {

            Institution institution = (Institution) DataController.getDao(Institution.class).queryBuilder().where(InstitutionDao.Properties.InstitutionId.eq(institutionId)).unique();

            if (institution == null) {
                Long id = DataController.createRandomGuid(Institution.class);
                institution = new Institution(id);
                institution.setName("Manual Institution");
                institution.setInstitutionId(institutionId);
                institution.setPopularity(0);
                institution.acceptChanges();
                institution.insertBatch();
            }

            Bank bank = (Bank) DataController.getDao(Bank.class).queryBuilder().where(BankDao.Properties.BankId.eq(memberId)).unique();

            if (bank == null) {

                Long id = DataController.createRandomGuid(Bank.class);
                bank = new Bank(id);
                bank.setBankName("Manual Bank");
                bank.setProcessStatus(Enums.BankRefreshStatus.STATUS_SUCCEEDED.index());
                bank.setBankId(memberId);
                bank.acceptChanges();
                bank.insertBatch();

            } else {

                bank.setInstitutionId(institution.getId());
                bank.acceptChanges();
                bank.updateBatch();
            }

            institution.resetBanks();

            if (bank.getDataStateEnum() == DataState.DATA_STATE_DELETED) {
                bank.setDataStateEnum(DataState.DATA_STATE_MODIFIED);
            }

            setBank(bank);
            bank.resetBankAccounts();

            DataController.save();
        }
    }

    // KEEP METHODS END

}
